# import "std/collections/vec" as V exposing { Vec }
# import "std/collections/map" as M
# import "std/collections/stack" exposing { Stack }
# import "std/collections/queue"

let y = x + 1
let x = 1
let p: &Int = &y
let r = p()

# fn main() {
#   XXXprint 1.5
#   let x = 1
# #  let y, z = 5
# #  mut u, v = 1, 4
#   foo()
# }
# 
# fn foo() {
#   XXXprint "This is a dependency"
#   main()
# }
# 
# fn add(a: Int, b: Int): Int {
#   a + b
# }
# 
# fn swap(a: &Int, b: &Int) {
#   let t = *a
#   *a = *b
#   *b = t
# }

# These are examples of circular dependencies
# that should not compile.
# let x = y + 1
# let y = x - 1
# let z = z + 1
# let bar = calls_baz() - 1
# fn calls_baz() {
#   baz()
# } 
# fn baz() {
#   let barf = bar + 1
# } 
